import fs from 'fs';
import { glob } from 'glob';
import path from 'path';

const inputFile = path.resolve(process.cwd(), 'locales/en.json');
const outputFile = path.resolve(process.cwd(), 'src/types/i18n.d.ts');
const srcDir = path.resolve(process.cwd(), 'src').replace(/\\/g, '/');

let hasError = false;

// --- Helper Functions ---

function getAllKeys(obj, prefix = '') {
  return Object.keys(obj).reduce((acc, key) => {
    const pre = prefix.length ? `${prefix}.` : '';
    if (typeof obj[key] === 'object' && obj[key] !== null) {
      Object.assign(acc, getAllKeys(obj[key], pre + key));
    } else {
      acc[pre + key] = false; // Mark as not found initially
    }
    return acc;
  }, {});
}

function deletePath(obj, path) {
  const parts = path.split('.');
  let current = obj;
  for (let i = 0; i < parts.length - 1; i++) {
    const part = parts[i];
    if (current && typeof current === 'object' && part in current) {
      current = current[part];
    } else {
      return; // Path doesn't exist
    }
  }
  if (current && typeof current === 'object') {
    delete current[parts[parts.length - 1]];
  }
}

function cleanupEmptyObjects(obj) {
  for (const key in obj) {
    if (typeof obj[key] === 'object' && obj[key] !== null) {
      cleanupEmptyObjects(obj[key]);
      if (Object.keys(obj[key]).length === 0) {
        delete obj[key];
      }
    }
  }
}

function generateType(obj, indent = '  ') {
  let typeString = '{\n';
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const value = obj[key];
      const safeKey = key.includes("'") ? `"${key}"` : key;

      if (typeof value === 'object' && value !== null) {
        typeString += `${indent}${safeKey}: ${generateType(value, indent + '  ')};\n`;
      } else {
        typeString += `${indent}${safeKey}: string;\n`;
      }
    }
  }
  typeString += `${indent.slice(0, -2)}}`;
  return typeString;
}

// --- Main Execution ---

async function run() {
  try {
    const shouldRemove = process.argv.includes('--remove');
    let messages = JSON.parse(fs.readFileSync(inputFile, 'utf-8'));

    // --- Part 1: Unused Key Detection & Removal ---
    console.log('Searching for unused i18n keys...');
    const allKeys = getAllKeys(messages);
    const keySet = new Set(Object.keys(allKeys));
    const files = await glob(`${srcDir}/**/*.{vue,ts}`);

    for (const file of files) {
      const content = fs.readFileSync(file, 'utf-8');
      for (const key of keySet) {
        if (allKeys[key]) continue;
        const escapedKey = key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const keyLiteralRegex = new RegExp(`(['"\`])${escapedKey}\\1`);
        if (keyLiteralRegex.test(content)) {
          allKeys[key] = true;
        }
      }
      const dynamicKeyRegex = /t\(`([^`]+)`\)/g;
      let match;
      while ((match = dynamicKeyRegex.exec(content)) !== null) {
        const staticPart = match[1].split('${')[0];
        if (staticPart) {
          for (const key of keySet) {
            if (key.startsWith(staticPart)) {
              allKeys[key] = true;
            }
          }
        }
      }
    }

    const unusedKeys = Object.keys(allKeys).filter((key) => !allKeys[key]);

    if (unusedKeys.length > 0) {
      if (shouldRemove) {
        console.warn('\n--remove flag detected. Removing unused i18n keys...');
        unusedKeys.forEach((key) => {
          deletePath(messages, key);
          console.log(`- Removed: ${key}`);
        });
        cleanupEmptyObjects(messages);
        fs.writeFileSync(inputFile, JSON.stringify(messages, null, 2) + '\n', 'utf-8');
        console.log(`\nSuccessfully removed ${unusedKeys.length} keys from ${inputFile}.`);
      } else {
        console.warn('\nFound unused i18n keys:');
        unusedKeys.forEach((key) => console.log(`- ${key}`));
        console.log(`\nTotal unused keys: ${unusedKeys.length}`);
        console.error('Error: Please remove these keys or run with the --remove flag to fix automatically.');
        hasError = true;
      }
    } else {
      console.log('âœ… No unused i18n keys found.');
    }

    if (hasError) return;

    // --- Part 2: Type Generation ---
    console.log('\nGenerating TypeScript types for i18n...');
    const finalMessages = JSON.parse(fs.readFileSync(inputFile, 'utf-8'));
    const generatedType = generateType(finalMessages);
    const fileContent = `// This file is auto-generated by manage-i18n.js\n// Do not edit this file directly\n\nexport interface MessageSchema ${generatedType}\n`;
    fs.writeFileSync(outputFile, fileContent, 'utf-8');
    console.log(`Successfully generated i18n types at ${outputFile}`);
  } catch (error) {
    console.error('An error occurred during i18n script:', error);
    hasError = true;
  } finally {
    if (hasError) {
      process.exit(1);
    }
  }
}

run();
